<!doctype html>
<html lang="zh-Hant">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Bubble Wall TV</title>

    <style>
        html,
        body {
            margin: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #050814;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>
    <canvas id="c"></canvas>

    <script>
        (() => {
            const canvas = document.getElementById("c");
            const ctx = canvas.getContext("2d", { alpha: false });

            // =========================================================
            // ✅ 一個參數切換模式：
            // "bubble"   = 泡泡本身有顏色
            // "lightbox" = 泡泡白色＋燈箱背光染色（bubble wall）
            // =========================================================
            const COLOR_MODE = "lightbox"; // <-- "bubble" 或 "lightbox"

            // ===== 版面 =====
            const PANELS_X = 4;

            // ===== 顏色（藍↔紫↔青，超慢變）=====
            const HUE_CYCLE_SECONDS = 240;
            const HUE_MIN = 200;
            const HUE_MAX = 285;
            const BUBBLE_S = 0.78;
            const BUBBLE_V = 0.93;

            // ===== 泡泡（✅ 已改：更多）=====
            const BUBBLES_PER_PANEL = 420; // 原本 280 → 更密
            const SPEED_MIN = 100;
            const SPEED_MAX = 200;
            const RADIUS_MIN = 2.5;
            const RADIUS_MAX = 8.5;

            const CENTER_SPREAD = 0.07;
            const UPWARD_SPREAD = 0.35;
            const TOP_SLOW_MIN = 0.18;
            const RESPAWN_Y = -0.25;

            // ===== 視覺（✅ 已改：更亮）=====
            const TRAIL_FADE = 0.10;   // 原本 0.085 → 更乾淨更亮的殘影
            const VIGNETTE = 0.55;
            const GRID_ALPHA = 0.08;

            const GRAIN = 12;

            // ✅ 整體亮度倍率（新增）
            const BRIGHTNESS = 1.35; // 1.0~2.0

            // ✅ 垂直 jitter：X 幾乎關掉、Y 拉強 + 讓 Y jitter 隨時間漂移成「直向流」
            const JITTER_X = 0.00;
            const JITTER_Y = 1.60;
            const JITTER_FLOW_SPEED = 2.2;

            // ✅ 水平漂移/擺動（保留很小即可）
            const DRIFT_X_SCALE = 0.04;
            const WOBBLE_X_SCALE = 0.004;

            // 底色
            const BASE_BG_R = 6, BASE_BG_G = 10, BASE_BG_B = 22;

            // lightbox 背光
            const LIGHTBOX_STRENGTH = 0.55;
            const WHITE_BUBBLE_ALPHA_SCALE = 1.15;

            let paused = false;
            let dpr = Math.max(1, Math.min(2, devicePixelRatio || 1));
            let W = 0, H = 0;

            function resize() {
                W = Math.floor(innerWidth * dpr);
                H = Math.floor(innerHeight * dpr);
                canvas.width = W;
                canvas.height = H;
                initBubbles();
            }
            addEventListener("resize", resize, { passive: true });

            function hsvToRgb(h, s, v) {
                h = ((h % 360) + 360) % 360;
                const c = v * s;
                const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
                const m = v - c;
                let r = 0, g = 0, b = 0;
                if (h < 60) [r, g, b] = [c, x, 0];
                else if (h < 120) [r, g, b] = [x, c, 0];
                else if (h < 180) [r, g, b] = [0, c, x];
                else if (h < 240) [r, g, b] = [0, x, c];
                else if (h < 300) [r, g, b] = [x, 0, c];
                else[r, g, b] = [c, 0, x];
                return [
                    Math.round((r + m) * 255),
                    Math.round((g + m) * 255),
                    Math.round((b + m) * 255)
                ];
            }

            // 2D integer hash -> [0,1)
            function hash2(x, y) {
                let n = (x * 374761393 + y * 668265263) ^ (x * y);
                n = (n ^ (n >> 13)) * 1274126177;
                n = (n ^ (n >> 16)) >>> 0;
                return n / 4294967296;
            }

            // ---------------- 泡泡資料 ----------------
            const bubbles = [];

            function spawnBubble(panel) {
                const pw = W / PANELS_X;
                const cx = panel * pw + pw / 2;

                const drift = (Math.random() * 2 - 1) * (pw * 0.10);
                const wobbleF = 0.6 + Math.random() * 1.8;
                const wobbleP = Math.random() * Math.PI * 2;

                return {
                    panel,
                    x: cx + (Math.random() - 0.5) * pw * CENTER_SPREAD,
                    y: H + Math.random() * 60,
                    vx: (Math.random() - 0.5) * pw * CENTER_SPREAD,
                    vy: SPEED_MIN + Math.random() * (SPEED_MAX - SPEED_MIN),
                    r: RADIUS_MIN + Math.random() * (RADIUS_MAX - RADIUS_MIN),

                    // ✅ 已改：更亮（原本 0.12~0.52）
                    alpha: 0.22 + Math.random() * 0.60,

                    life: 0,
                    drift,
                    wobbleF,
                    wobbleP
                };
            }

            function initBubbles() {
                bubbles.length = 0;
                for (let p = 0; p < PANELS_X; p++) {
                    for (let i = 0; i < BUBBLES_PER_PANEL; i++) {
                        const b = spawnBubble(p);
                        b.y = Math.pow(Math.random(), 0.65) * H;
                        bubbles.push(b);
                    }
                }
            }

            function drawVignette() {
                const g = ctx.createRadialGradient(
                    W * 0.5, H * 0.5, Math.min(W, H) * 0.2,
                    W * 0.5, H * 0.5, Math.max(W, H) * 0.9
                );
                g.addColorStop(0, "rgba(0,0,0,0)");
                g.addColorStop(1, `rgba(0,0,0,${VIGNETTE})`);
                ctx.fillStyle = g;
                ctx.fillRect(0, 0, W, H);
            }

            function drawGrid() {
                ctx.save();
                ctx.strokeStyle = `rgba(255,255,255,${GRID_ALPHA})`;
                ctx.lineWidth = Math.max(1, Math.floor(1.5 * dpr));
                const pw = W / PANELS_X;
                for (let i = 1; i < PANELS_X; i++) {
                    const x = Math.round(i * pw) + 0.5;
                    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
                }
                ctx.restore();
            }

            function drawLightboxBacklight(R, G, B) {
                const pw = W / PANELS_X;
                ctx.save();
                ctx.globalCompositeOperation = "screen";
                for (let p = 0; p < PANELS_X; p++) {
                    const x0 = p * pw;
                    const cx = x0 + pw * 0.5;
                    const cy = H * 0.78;
                    const r1 = Math.max(pw, H) * 0.08;
                    const r2 = Math.max(pw, H) * 0.70;
                    const grad = ctx.createRadialGradient(cx, cy, r1, cx, cy, r2);
                    grad.addColorStop(0, `rgba(${R},${G},${B},${0.55 * LIGHTBOX_STRENGTH})`);
                    grad.addColorStop(0.5, `rgba(${R},${G},${B},${0.22 * LIGHTBOX_STRENGTH})`);
                    grad.addColorStop(1, `rgba(${R},${G},${B},0)`);
                    ctx.fillStyle = grad;
                    ctx.fillRect(x0, 0, pw, H);
                }
                ctx.restore();
            }

            // ✅ 直向水痕 grain（保持原本味道，但方向偏直）
            function addGrain(now) {
                if (GRAIN <= 0) return;
                const img = ctx.getImageData(0, 0, W, H);
                const data = img.data;
                const seed = (now * 0.001) % 10000;

                for (let y = 0; y < H; y++) {
                    for (let x = 0; x < W; x++) {
                        const i = (y * W + x) * 4;

                        // x 權重大 → 直向水痕
                        const idx1D = x * 4096 + y;
                        const n = Math.sin((idx1D + seed) * 0.0000123) * 43758.5453;
                        const g = ((n - Math.floor(n)) - 0.5) * 2;
                        const add = g * GRAIN;

                        data[i] = Math.max(0, Math.min(255, data[i] + add));
                        data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + add));
                        data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + add));
                    }
                }
                ctx.putImageData(img, 0, 0);
            }

            resize();
            ctx.fillStyle = `rgb(${BASE_BG_R},${BASE_BG_G},${BASE_BG_B})`;
            ctx.fillRect(0, 0, W, H);

            let last = performance.now();
            function tick(now) {
                requestAnimationFrame(tick);
                if (paused) { last = now; return; }

                const dt = Math.min(0.033, (now - last) / 1000);
                last = now;
                const t = now / 1000;

                const hue =
                    HUE_MIN + (HUE_MAX - HUE_MIN) *
                    (0.5 + 0.5 * Math.sin((t / HUE_CYCLE_SECONDS) * Math.PI * 2));
                const [CR, CG, CB] = hsvToRgb(hue, BUBBLE_S, BUBBLE_V);

                // 拖影底
                ctx.fillStyle = `rgba(${BASE_BG_R},${BASE_BG_G},${BASE_BG_B},${TRAIL_FADE})`;
                ctx.fillRect(0, 0, W, H);

                if (COLOR_MODE === "lightbox") {
                    drawLightboxBacklight(CR, CG, CB);
                }

                ctx.globalCompositeOperation = "lighter";
                const pw = W / PANELS_X;

                for (const b of bubbles) {
                    const heightFactor = Math.max(TOP_SLOW_MIN, b.y / H);

                    // 主要往上
                    b.y -= b.vy * heightFactor * dt;

                    // 水平幾乎不動
                    const wob = Math.sin(t * b.wobbleF + b.wobbleP + b.y * 0.01) * (pw * WOBBLE_X_SCALE);
                    b.x += (b.drift * DRIFT_X_SCALE + wob) * dt * 60;

                    b.x += b.vx * dt * 0.12;
                    b.vx *= (1 + UPWARD_SPREAD * dt * 0.22);

                    b.life += dt;

                    if (b.y < H * RESPAWN_Y) {
                        Object.assign(b, spawnBubble(b.panel));
                    }

                    // 夾在格內
                    const x0 = b.panel * pw;
                    const left = x0 + 2;
                    const right = x0 + pw - 2;
                    if (b.x < left) b.x = left;
                    if (b.x > right) b.x = right;

                    // 垂直 jitter（jy 流動）
                    const nx = (b.x * 0.06) | 0;
                    const nyFlow = ((b.y * 0.06) + t * JITTER_FLOW_SPEED) | 0;

                    const n1 = hash2(nx, nyFlow);
                    const n2 = hash2(nx + 1013, nyFlow + 917);

                    const jx = (n1 - 0.5) * 2;
                    const jy = (n2 - 0.5) * 2;

                    const gx = b.x + jx * JITTER_X;
                    const gy = b.y + jy * JITTER_Y;

                    const rr = b.r * (0.75 + n1 * 0.8);

                    const topBoost = 0.65 + 0.35 * (1 - b.y / H);
                    const fade = 1 - Math.min(1, (H - b.y) / H) * 0.40;

                    let a = b.alpha * fade * topBoost;

                    // ✅ 更亮（整體倍率）
                    a *= BRIGHTNESS;

                    let R = CR, G = CG, B = CB;
                    if (COLOR_MODE === "lightbox") {
                        R = 255; G = 255; B = 255;
                        a *= WHITE_BUBBLE_ALPHA_SCALE;
                    }

                    const grad = ctx.createRadialGradient(gx, gy, 0, gx, gy, rr * 2.4);
                    grad.addColorStop(0, `rgba(${R},${G},${B},${0.55 * a})`);
                    grad.addColorStop(0.35, `rgba(${R},${G},${B},${0.20 * a})`);
                    grad.addColorStop(1, `rgba(${R},${G},${B},0)`);
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(gx, gy, rr * 2.4, 0, Math.PI * 2);
                    ctx.fill();

                    // 核心亮點
                    ctx.fillStyle = `rgba(${R},${G},${B},${0.25 * a})`;
                    ctx.beginPath();
                    ctx.arc(gx, gy, Math.max(0.8 * dpr, rr * 0.55), 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.globalCompositeOperation = "source-over";
                addGrain(now);
                drawVignette();
                drawGrid();
            }

            requestAnimationFrame(tick);
            addEventListener("click", () => paused = !paused);
        })();
    </script>
</body>

</html>