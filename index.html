<!doctype html>
<html lang="zh-Hant">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Bubble Wall</title>

    <style>
        :root {
            --bg: #050814;
            --panel: #0b1022;
            --glow1: #6aa8ff;
            --glow2: #b58cff;
            --text: #e9ecff;
        }

        * {
            box-sizing: border-box
        }

        html,
        body {
            margin: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: var(--bg);
            color: var(--text);
            font-family: system-ui, -apple-system, "Segoe UI", "Noto Sans TC", "PingFang TC", sans-serif;
        }

        #bg {
            position: fixed;
            inset: 0;
            width: 100%;
            height: 100%;
            display: block;
            z-index: 0;
        }

        body {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .lamp {
            width: min(92vw, 560px);
            aspect-ratio: 9/16;
            border-radius: 28px;
            padding: 40px 28px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            position: relative;
            overflow: hidden;
            z-index: 1;

            background:
                radial-gradient(140% 90% at 50% 90%, rgba(120, 160, 255, .14), transparent 60%),
                linear-gradient(180deg, #0d1330, #070a1a 70%);
            box-shadow:
                0 40px 120px rgba(0, 0, 0, .75),
                inset 0 0 80px rgba(120, 160, 255, .10);
            backdrop-filter: blur(6px);
        }

        .title {
            text-align: center;
        }

        .title h1 {
            margin: 0;
            font-size: 28px;
            letter-spacing: .12em;
            text-transform: uppercase;
            background: linear-gradient(90deg, var(--glow1), var(--glow2));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 18px rgba(160, 180, 255, .35);
        }

        .title p {
            margin: 10px 0 0;
            font-size: 14px;
            opacity: .75;
            letter-spacing: .1em;
        }

        .buttons {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 24px;
            margin-bottom: 20px;
        }

        .btnWrap {
            position: relative;
            width: 100%;
            border-radius: 18px;
            overflow: hidden;
        }

        .btnGlow {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            display: block;
            opacity: 0;
            transition: opacity .22s ease;
            pointer-events: none;
            filter: blur(0.2px);
        }

        .btnWrap:hover .btnGlow {
            opacity: 1;
        }

        .btn {
            position: relative;
            z-index: 1;
            display: block;
            width: 100%;
            padding: 26px 20px;
            border-radius: 18px;
            text-align: center;
            font-size: 22px;
            font-weight: 600;
            letter-spacing: .08em;
            color: white;
            text-decoration: none;

            background:
                linear-gradient(180deg,
                    rgba(120, 160, 255, .33),
                    rgba(60, 90, 200, .22));
            box-shadow:
                0 0 0 1px rgba(140, 170, 255, .25),
                0 14px 40px rgba(80, 120, 255, .25),
                inset 0 0 30px rgba(160, 200, 255, .18);
            transition: transform .25s ease, box-shadow .25s ease;
        }

        .btn::after {
            content: "";
            position: absolute;
            inset: 0;
            border-radius: inherit;
            box-shadow: 0 0 46px rgba(160, 200, 255, .45);
            opacity: 0;
            transition: opacity .25s ease;
            pointer-events: none;
        }

        .btnWrap:hover .btn {
            transform: translateY(-4px);
            box-shadow:
                0 0 0 1px rgba(170, 200, 255, .35),
                0 22px 60px rgba(120, 160, 255, .45),
                inset 0 0 40px rgba(180, 220, 255, .28);
        }

        .btnWrap:hover .btn::after {
            opacity: 1;
        }

        .btn span {
            display: block;
            margin-top: 6px;
            font-size: 13px;
            opacity: .75;
            font-weight: 400;
            letter-spacing: .05em;
        }

        .footer {
            font-size: 12px;
            opacity: .55;
            letter-spacing: .08em;
        }

        @media (max-height:680px) {
            .lamp {
                padding: 28px 22px
            }

            .btn {
                padding: 22px 18px;
                font-size: 20px
            }
        }
    </style>
</head>

<body>
    <canvas id="bg"></canvas>

    <div class="lamp">
        <div class="title">
            <h1>Bubble Wall</h1>
        </div>

        <div class="buttons">
            <div class="btnWrap" data-variant="a">
                <canvas class="btnGlow"></canvas>
                <a class="btn" href="./bw1.html">
                    Bubble Wall · A
                    <span>Color Bubble with glass effect</span>
                </a>
            </div>

            <div class="btnWrap" data-variant="b">
                <canvas class="btnGlow"></canvas>
                <a class="btn" href="./bw2.html">
                    Bubble Wall · B
                    <span>White Bubble Light Box</span>
                </a>
            </div>

            <div class="btnWrap" data-variant="b">
                <canvas class="btnGlow"></canvas>
                <a class="btn" href="./bw3.html">
                    Bubble Wall ·C
                    <span>Another bubble approach</span>
                </a>
            </div>
        </div>

        <div class="footer">Touch</div>
    </div>

    <script>
        (() => {
            const bg = document.getElementById("bg");
            const bctx = bg.getContext("2d", { alpha: false });

            let dpr = Math.max(1, Math.min(2, devicePixelRatio || 1));
            let W = 0, H = 0;

            function resizeBG() {
                W = Math.floor(innerWidth * dpr);
                H = Math.floor(innerHeight * dpr);
                bg.width = W; bg.height = H;
            }
            addEventListener("resize", resizeBG, { passive: true });
            resizeBG();

            // 背景泡泡（少量、慢、柔）
            const BG_COUNT = 90;
            const BG_SPEED_MIN = 14;
            const BG_SPEED_MAX = 48;
            const BG_R_MIN = 6;
            const BG_R_MAX = 22;

            const bgBubbles = [];
            function rand(a, b) { return a + Math.random() * (b - a); }

            function spawnBgBubble() {
                return {
                    x: rand(0, W),
                    y: rand(0, H),
                    r: rand(BG_R_MIN, BG_R_MAX) * dpr,
                    vy: rand(BG_SPEED_MIN, BG_SPEED_MAX) * dpr,
                    vx: rand(-10, 10) * dpr,
                    a: rand(0.04, 0.11)
                };
            }
            function initBg() {
                bgBubbles.length = 0;
                for (let i = 0; i < BG_COUNT; i++) bgBubbles.push(spawnBgBubble());
            }
            initBg();

            function hsvToRgb(h, s, v) {
                h = ((h % 360) + 360) % 360;
                const c = v * s;
                const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
                const m = v - c;
                let r = 0, g = 0, b = 0;
                if (h < 60) [r, g, b] = [c, x, 0];
                else if (h < 120) [r, g, b] = [x, c, 0];
                else if (h < 180) [r, g, b] = [0, c, x];
                else if (h < 240) [r, g, b] = [0, x, c];
                else if (h < 300) [r, g, b] = [x, 0, c];
                else[r, g, b] = [c, 0, x];
                return [
                    Math.round((r + m) * 255),
                    Math.round((g + m) * 255),
                    Math.round((b + m) * 255)
                ];
            }

            // 背景色相慢變（跟你 bubble wall 氛圍一致）
            const HUE_MIN = 205, HUE_MAX = 285;
            const HUE_CYCLE = 260; // 秒

            let last = performance.now();
            function tickBG(now) {
                requestAnimationFrame(tickBG);
                const dt = Math.min(0.033, (now - last) / 1000);
                last = now;
                const t = now / 1000;

                const hue = HUE_MIN + (HUE_MAX - HUE_MIN) * (0.5 + 0.5 * Math.sin((t / HUE_CYCLE) * Math.PI * 2));
                const [R, G, B] = hsvToRgb(hue, 0.70, 0.95);

                // 深底 + 微拖影
                bctx.fillStyle = "rgba(5,8,20,0.18)";
                bctx.fillRect(0, 0, W, H);

                // 柔光泡泡
                bctx.globalCompositeOperation = "lighter";
                for (const p of bgBubbles) {
                    p.y -= p.vy * dt;
                    p.x += p.vx * dt;

                    if (p.y < -p.r * 3) { p.y = H + p.r * 3; p.x = rand(0, W); }
                    if (p.x < -p.r * 3) p.x = W + p.r * 3;
                    if (p.x > W + p.r * 3) p.x = -p.r * 3;

                    const g = bctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r * 2.6);
                    g.addColorStop(0, `rgba(${R},${G},${B},${0.45 * p.a})`);
                    g.addColorStop(0.35, `rgba(${R},${G},${B},${0.18 * p.a})`);
                    g.addColorStop(1, `rgba(${R},${G},${B},0)`);
                    bctx.fillStyle = g;
                    bctx.beginPath();
                    bctx.arc(p.x, p.y, p.r * 2.6, 0, Math.PI * 2);
                    bctx.fill();
                }
                bctx.globalCompositeOperation = "source-over";

                // 暗角
                const vg = bctx.createRadialGradient(W * 0.5, H * 0.4, Math.min(W, H) * 0.12, W * 0.5, H * 0.5, Math.max(W, H) * 0.85);
                vg.addColorStop(0, "rgba(0,0,0,0)");
                vg.addColorStop(1, "rgba(0,0,0,0.62)");
                bctx.fillStyle = vg;
                bctx.fillRect(0, 0, W, H);
            }
            requestAnimationFrame(tickBG);

            // =========================================================
            // 2) 按鈕 hover：泡泡亮起（每個按鈕一張小 canvas）
            // =========================================================
            const wraps = [...document.querySelectorAll(".btnWrap")];

            function setupButtonGlow(wrap) {
                const cv = wrap.querySelector(".btnGlow");
                const ctx2 = cv.getContext("2d", { alpha: true });

                function resizeBtn() {
                    const r = wrap.getBoundingClientRect();
                    cv.width = Math.floor(r.width * dpr);
                    cv.height = Math.floor(r.height * dpr);
                }
                resizeBtn();
                addEventListener("resize", resizeBtn, { passive: true });

                // 做一組固定泡泡點（hover 時看起來像亮起）
                const N = 22;
                const pts = Array.from({ length: N }, () => ({
                    x: Math.random(),
                    y: Math.random(),
                    r: (0.09 + Math.random() * 0.18),
                    a: (0.10 + Math.random() * 0.22),
                    w: (0.7 + Math.random() * 1.8),
                    p: Math.random() * Math.PI * 2
                }));

                let hovering = false;
                wrap.addEventListener("mouseenter", () => hovering = true);
                wrap.addEventListener("mouseleave", () => hovering = false);

                function draw(now) {
                    requestAnimationFrame(draw);
                    const t = now / 1000;

                    // 只有 hover 時才重畫（省 CPU）
                    if (!hovering) return;

                    const w = cv.width, h = cv.height;
                    ctx2.clearRect(0, 0, w, h);
                    ctx2.globalCompositeOperation = "lighter";

                    // 兩顆按鈕給不同色調（A 偏藍、B 偏紫）
                    const isB = wrap.dataset.variant === "b";
                    const baseHue = isB ? 276 : 215;
                    const [R, G, B] = hsvToRgb(baseHue + 10 * Math.sin(t * 0.6), 0.72, 0.98);

                    // 底部一層柔光（像泡泡燈箱被打亮）
                    const g0 = ctx2.createRadialGradient(w * 0.5, h * 0.8, 0, w * 0.5, h * 0.8, Math.max(w, h) * 0.9);
                    g0.addColorStop(0, `rgba(${R},${G},${B},0.20)`);
                    g0.addColorStop(1, `rgba(${R},${G},${B},0)`);
                    ctx2.fillStyle = g0;
                    ctx2.fillRect(0, 0, w, h);

                    // 一顆一顆泡泡亮起（微動畫）
                    for (const p of pts) {
                        const px = p.x * w + Math.sin(t * p.w + p.p) * 10 * dpr;
                        const py = p.y * h + Math.cos(t * p.w * 0.8 + p.p) * 6 * dpr;
                        const rr = p.r * Math.min(w, h) * (0.70 + 0.35 * Math.sin(t * 1.4 + p.p));

                        const gg = ctx2.createRadialGradient(px, py, 0, px, py, rr * 2.2);
                        gg.addColorStop(0, `rgba(${R},${G},${B},${0.55 * p.a})`);
                        gg.addColorStop(0.35, `rgba(${R},${G},${B},${0.20 * p.a})`);
                        gg.addColorStop(1, `rgba(${R},${G},${B},0)`);
                        ctx2.fillStyle = gg;
                        ctx2.beginPath();
                        ctx2.arc(px, py, rr * 2.2, 0, Math.PI * 2);
                        ctx2.fill();

                        // 核心亮點
                        ctx2.fillStyle = `rgba(255,255,255,${0.10 * p.a})`;
                        ctx2.beginPath();
                        ctx2.arc(px, py, Math.max(1 * dpr, rr * 0.55), 0, Math.PI * 2);
                        ctx2.fill();
                    }

                    ctx2.globalCompositeOperation = "source-over";
                }

                requestAnimationFrame(draw);
            }

            wraps.forEach(setupButtonGlow);
        })();
    </script>
</body>

</html>